<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SuperLU: SRC/slu_ddefs.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>SRC/slu_ddefs.h File Reference</h1>Header file for real operations. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="slu__Cnames_8h-source.html">slu_Cnames.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="supermatrix_8h-source.html">supermatrix.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="slu__util_8h-source.html">slu_util.h</a>&quot;</code><br>

<p>
<a href="slu__ddefs_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#b6fd6105e64ed14a0c9281326f05e623">int_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#2c8a0856fb555c352ed0f43989d1d71e">dgssv</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Driver routines.  <a href="#2c8a0856fb555c352ed0f43989d1d71e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#55ccb099a318043965a941a7fd8cb095">dgssvx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, int *, char *, double *, double *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, void *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *, double *, double *, double *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#3a3d0af1360639f21edacae8f93eb828">dCreate_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, double *, int *, int *, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supernodal LU factor related.  <a href="#3a3d0af1360639f21edacae8f93eb828"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#0807ebe794e4353779d2947e9df0f485">dCreate_CompRow_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, double *, int *, int *, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#21c06d544ecb9028142abd70a583dd68">dCopy_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy matrix A into matrix B.  <a href="#21c06d544ecb9028142abd70a583dd68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#08d9d6bf3069c89c0c1207967599c4fc">dCreate_Dense_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, double *, int, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#649094ccbc54eaed4ca787fd970049f6">dCreate_SuperNode_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, double *, int *, int *, int *, int *, int *, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#9bf038cd2c143a48a14a562ca1f67e27">dCopy_Dense_Matrix</a> (int, int, double *, int, double *, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a two-dimensional matrix X to another matrix Y.  <a href="#9bf038cd2c143a48a14a562ca1f67e27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#8086902aa8be3fc7d04c3c82ec3a79dc">countnz</a> (const int, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L.  <a href="#8086902aa8be3fc7d04c3c82ec3a79dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#7061332d759d7e4d73c1b2e5cb0bf2bf">fixupL</a> (const int, const int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix up the data storage lsub for L-subscripts. It removes the subscript sets for structural pruning, and applies permuation to the remaining subscripts.  <a href="#7061332d759d7e4d73c1b2e5cb0bf2bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#3a86154bfb6453d6358ef52ab1ecfe2d">dallocateA</a> (int, int, double **, int **, int **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate storage for original matrix A.  <a href="#3a86154bfb6453d6358ef52ab1ecfe2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#0bd7d78413e339698b01a44765db04c3">dgstrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double, int, int, int *, void *, int, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#b0fe8232652578797bee690fcd8adfd0">dsnode_dfs</a> (const int, const int, const int *, const int *, const int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#289847afa67421491f96367c7f2fe90f">dsnode_bmod</a> (const int, const int, const int, double *, double *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numeric block updates within the relaxed snode.  <a href="#289847afa67421491f96367c7f2fe90f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#ca83bf1fa16a64ea2ee575574a8bb969">dpanel_dfs</a> (const int, const int, const int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, double *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#22cfb6f57857cc7cb3d853ee5467656f">dpanel_bmod</a> (const int, const int, const int, const int, double *, double *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#1414b492a902b8da3c2e1b620b922644">dcolumn_dfs</a> (const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#351174e818ab7d5149ec9dc116b3a242">dcolumn_bmod</a> (const int, const int, double *, double *, int *, int *, int, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#9dfcee23fab091d05a4301e25b3b4227">dcopy_to_ucol</a> (int, int, int *, int *, int *, double *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#09624f0c44de80ee2731e44a333ee01c">dpivotL</a> (const int, const double, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#98c8e37fbd3e285de80ae5ebc633c64a">dpruneL</a> (const int, const int *, const int, const int, const int *, const int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#efc4e420b7fa27a770b4b9db6ba5cfc4">dreadmt</a> (int *, int *, int *, double **, int **, int **)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#ebd8d273c58591dc435e1afd4e837d9f">dGenXtrue</a> (int, int, double *, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#ac4705e1c2b9892fd11115ef3cd40bb8">dFillRHS</a> (<a class="el" href="slu__util_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, int, double *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let rhs[i] = sum of i-th row of A, so the solution vector is all 1's.  <a href="#ac4705e1c2b9892fd11115ef3cd40bb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#8d42744f59d84a50b19aa4c28cf7aded">dgstrs</a> (<a class="el" href="slu__util_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#fba0263dae6d5d3a700e9e7a120d6b87">dgsequ</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *, double *, double *, double *, double *, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Driver related.  <a href="#fba0263dae6d5d3a700e9e7a120d6b87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#7c3a821ed273808f662ddd41be6c6c97">dlaqgs</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *, double *, double, double, double, char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#1a5e04478d6d6e4f714fee3080f5a065">dgscon</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double, double *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#2c1536c187133a8a8ea5d856a222eec5">dPivotGrowth</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#424f8b36e210117c4dea0c590e977bb4">dgsrfs</a> (<a class="el" href="slu__util_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, char *, double *, double *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *, double *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#f7ab3b2b81d10a67b258956bfc468740">sp_dtrsv</a> (char *, char *, char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves one of the systems of equations A*x = b, or A'*x = b.  <a href="#f7ab3b2b81d10a67b258956bfc468740"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#505f6c005fe6a0cdcbf00512a1e4823a">sp_dgemv</a> (char *, double, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *, int, double, double *, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A'*x + beta*y,.  <a href="#505f6c005fe6a0cdcbf00512a1e4823a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#b776edfed8eb517dc4d037e76ed2bb24">sp_dgemm</a> (char *, char *, int, int, int, double, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *, int, double, double *, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#12a4221c734db9540566cb1386a2e6fc">dLUMemInit</a> (<a class="el" href="slu__util_8h.html#c785c8235480e5cfef9848d89c047c0a">fact_t</a>, void *, int, int, int, int, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, int **, double **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory-related.  <a href="#12a4221c734db9540566cb1386a2e6fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#6248d2471a710335359db300b35c5066">dSetRWork</a> (int, int, double *, double **, double **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up pointers for real working arrays.  <a href="#6248d2471a710335359db300b35c5066"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#e7976837d1936a3150abf5dd62f0c211">dLUWorkFree</a> (int *, double *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the working storage used by factor routines.  <a href="#e7976837d1936a3150abf5dd62f0c211"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#4cc8cb916b6bf5f2238c374aa7339f4c">dLUMemXpand</a> (int, int, <a class="el" href="slu__util_8h.html#bd31f838aefffa46191d0d7dc36a96b2">MemType</a>, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand the data structures for L and U during the factorization.  <a href="#4cc8cb916b6bf5f2238c374aa7339f4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#47c4cf79f8c6305147a70de6da2696ac">doubleMalloc</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#2b7be732f4d725dd35799d772473625e">doubleCalloc</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#a7bf96909e8e3579499f46a84b28d9df">dmemory_usage</a> (const int, const int, const int, const int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#a28191998cfaddc30d4728535a39d996">dQuerySpace</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#be5e29734eb193fdda83f02fbb72a60a">dreadhb</a> (int *, int *, int *, double **, int **, int **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary routines.  <a href="#be5e29734eb193fdda83f02fbb72a60a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#fab4013ae32ca6413508cefa1e8143d5">dCompRow_to_CompCol</a> (int, int, int, double *, int *, int *, double **, int **, int **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a row compressed storage into a column compressed storage.  <a href="#fab4013ae32ca6413508cefa1e8143d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#b20cdc6e4aed319a43b967496932b3e0">dfill</a> (double *, int, double)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills a double precision array with a given value.  <a href="#b20cdc6e4aed319a43b967496932b3e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#d778c065ce9768d1f971d8a556752f11">dinf_norm_error</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, double *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the inf-norm of the error vector.  <a href="#d778c065ce9768d1f971d8a556752f11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#04b5542748fcc2fee77b587e31bb0a02">PrintPerf</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, double, double, double *, double *, char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#4908a093c1b9d8d96e3fbba6c29673c1">dPrint_CompCol_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routines for debugging.  <a href="#4908a093c1b9d8d96e3fbba6c29673c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#d6acd040a093d5858b9b77d347be954c">dPrint_SuperNode_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#d440b7616886349fe2cde5ac490b0f7d">dPrint_Dense_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#4eb909967bdba5d1c9e1adcfcba55be1">print_lu_col</a> (char *, int, int, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__ddefs_8h.html#c1bba297faf9fa0cb8d4e945138b5a21">check_tempv</a> (int, double *)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<pre> 
 -- SuperLU routine (version 3.0) --
 Univ. of California Berkeley, Xerox Palo Alto Research Center,
 and Lawrence Berkeley National Lab.
 October 15, 2003</pre><p>
<pre> Global data structures used in LU factorization -</pre><p>
<pre>   nsuper: supernodes = nsuper + 1, numbered [0, nsuper].
   (xsup,supno): supno[i] is the supernode no to which i belongs;
	xsup(s) points to the beginning of the s-th supernode.
	e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
	        xsup 0 1 2 4 7 12
	Note: dfs will be performed on supernode rep. relative to the new 
	      row pivoting ordering</pre><p>
<pre>   (xlsub,lsub): lsub[*] contains the compressed subscript of
	rectangular supernodes; xlsub[j] points to the starting
	location of the j-th column in lsub[*]. Note that xlsub 
	is indexed by column.
	Storage: original row subscripts</pre><p>
<pre>      During the course of sparse LU factorization, we also use
	(xlsub,lsub) for the purpose of symmetric pruning. For each
	supernode {s,s+1,...,t=s+r} with first column s and last
	column t, the subscript set
		lsub[j], j=xlsub[s], .., xlsub[s+1]-1
	is the structure of column s (i.e. structure of this supernode).
	It is used for the storage of numerical values.
	Furthermore,
		lsub[j], j=xlsub[t], .., xlsub[t+1]-1
	is the structure of the last column t of this supernode.
	It is for the purpose of symmetric pruning. Therefore, the
	structural subscripts can be rearranged without making physical
	interchanges among the numerical values.</pre><p>
<pre>	However, if the supernode has only one column, then we
	only keep one set of subscripts. For any subscript interchange
	performed, similar interchange must be done on the numerical
	values.</pre><p>
<pre>	The last column structures (for pruning) will be removed
	after the numercial LU factorization phase.</pre><p>
<pre>   (xlusup,lusup): lusup[*] contains the numerical values of the
	rectangular supernodes; xlusup[j] points to the starting
	location of the j-th column in storage vector lusup[*]
	Note: xlusup is indexed by column.
	Each rectangular supernode is stored by column-major
	scheme, consistent with Fortran 2-dim array storage.</pre><p>
<pre>   (xusub,ucol,usub): ucol[*] stores the numerical values of
	U-columns outside the rectangular supernodes. The row
	subscript of nonzero ucol[k] is stored in usub[k].
	xusub[i] points to the starting location of column i in ucol.
	Storage: new row subscripts; that is subscripts of PA.
 </pre> <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="b6fd6105e64ed14a0c9281326f05e623"></a><!-- doxytag: member="slu_ddefs.h::int_t" ref="b6fd6105e64ed14a0c9281326f05e623" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int <a class="el" href="slu__zdefs_8h.html#b6fd6105e64ed14a0c9281326f05e623">int_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c1bba297faf9fa0cb8d4e945138b5a21"></a><!-- doxytag: member="slu_ddefs.h::check_tempv" ref="c1bba297faf9fa0cb8d4e945138b5a21" args="(int, double *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void check_tempv           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="8086902aa8be3fc7d04c3c82ec3a79dc"></a><!-- doxytag: member="slu_ddefs.h::countnz" ref="8086902aa8be3fc7d04c3c82ec3a79dc" args="(const int, int *, int *, int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void countnz           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="3a86154bfb6453d6358ef52ab1ecfe2d"></a><!-- doxytag: member="slu_ddefs.h::dallocateA" ref="3a86154bfb6453d6358ef52ab1ecfe2d" args="(int, int, double **, int **, int **)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dallocateA           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="351174e818ab7d5149ec9dc116b3a242"></a><!-- doxytag: member="slu_ddefs.h::dcolumn_bmod" ref="351174e818ab7d5149ec9dc116b3a242" args="(const int, const int, double *, double *, int *, int *, int, GlobalLU_t *, SuperLUStat_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dcolumn_bmod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>dense</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>fpanelc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose:
 ========
 Performs numeric block updates (sup-col) in topological order.
 It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
 Special processing on the supernodal portion of L[*,j]
 Return value:   0 - successful return
               &gt; 0 - number of bytes allocated when run out of space
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="1414b492a902b8da3c2e1b620b922644"></a><!-- doxytag: member="slu_ddefs.h::dcolumn_dfs" ref="1414b492a902b8da3c2e1b620b922644" args="(const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dcolumn_dfs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======
   "column_dfs" performs a symbolic factorization on column jcol, and
   decide the supernode boundary.</pre><p>
<pre>   This routine does not use numeric values, but only use the RHS 
   row indices to start the dfs.</pre><p>
<pre>   A supernode representative is the last column of a supernode.
   The nonzeros in U[*,j] are segments that end at supernodal
   representatives. The routine returns a list of such supernodal 
   representatives in topological order of the dfs that generates them.
   The location of the first nonzero in each such supernodal segment
   (supernodal entry location) is also returned.</pre><p>
<pre> Local parameters
 ================
   nseg: no of segments in current U[*,j]
   jsuper: jsuper=EMPTY if column j does not belong to the same
	supernode as j-1. Otherwise, jsuper=nsuper.</pre><p>
<pre>   marker2: A-row --&gt; A-row/col (0/1)
   repfnz: SuperA-col --&gt; PA-row
   parent: SuperA-col --&gt; SuperA-col
   xplore: SuperA-col --&gt; index to L-structure</pre><p>
<pre> Return value
 ============
     0  success;
   &gt; 0  number of bytes allocated when run out of space.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="fab4013ae32ca6413508cefa1e8143d5"></a><!-- doxytag: member="slu_ddefs.h::dCompRow_to_CompCol" ref="fab4013ae32ca6413508cefa1e8143d5" args="(int, int, int, double *, int *, int *, double **, int **, int **)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dCompRow_to_CompCol           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="21c06d544ecb9028142abd70a583dd68"></a><!-- doxytag: member="slu_ddefs.h::dCopy_CompCol_Matrix" ref="21c06d544ecb9028142abd70a583dd68" args="(SuperMatrix *, SuperMatrix *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dCopy_CompCol_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="9bf038cd2c143a48a14a562ca1f67e27"></a><!-- doxytag: member="slu_ddefs.h::dCopy_Dense_Matrix" ref="9bf038cd2c143a48a14a562ca1f67e27" args="(int, int, double *, int, double *, int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dCopy_Dense_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="9dfcee23fab091d05a4301e25b3b4227"></a><!-- doxytag: member="slu_ddefs.h::dcopy_to_ucol" ref="9dfcee23fab091d05a4301e25b3b4227" args="(int, int, int *, int *, int *, double *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dcopy_to_ucol           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="3a3d0af1360639f21edacae8f93eb828"></a><!-- doxytag: member="slu_ddefs.h::dCreate_CompCol_Matrix" ref="3a3d0af1360639f21edacae8f93eb828" args="(SuperMatrix *, int, int, int, double *, int *, int *, Stype_t, Dtype_t, Mtype_t)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dCreate_CompCol_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="0807ebe794e4353779d2947e9df0f485"></a><!-- doxytag: member="slu_ddefs.h::dCreate_CompRow_Matrix" ref="0807ebe794e4353779d2947e9df0f485" args="(SuperMatrix *, int, int, int, double *, int *, int *, Stype_t, Dtype_t, Mtype_t)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dCreate_CompRow_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="08d9d6bf3069c89c0c1207967599c4fc"></a><!-- doxytag: member="slu_ddefs.h::dCreate_Dense_Matrix" ref="08d9d6bf3069c89c0c1207967599c4fc" args="(SuperMatrix *, int, int, double *, int, Stype_t, Dtype_t, Mtype_t)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dCreate_Dense_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="649094ccbc54eaed4ca787fd970049f6"></a><!-- doxytag: member="slu_ddefs.h::dCreate_SuperNode_Matrix" ref="649094ccbc54eaed4ca787fd970049f6" args="(SuperMatrix *, int, int, int, double *, int *, int *, int *, int *, int *, Stype_t, Dtype_t, Mtype_t)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dCreate_SuperNode_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b20cdc6e4aed319a43b967496932b3e0"></a><!-- doxytag: member="slu_ddefs.h::dfill" ref="b20cdc6e4aed319a43b967496932b3e0" args="(double *, int, double)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dfill           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ac4705e1c2b9892fd11115ef3cd40bb8"></a><!-- doxytag: member="slu_ddefs.h::dFillRHS" ref="ac4705e1c2b9892fd11115ef3cd40bb8" args="(trans_t, int, double *, int, SuperMatrix *, SuperMatrix *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dFillRHS           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="slu__util_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ebd8d273c58591dc435e1afd4e837d9f"></a><!-- doxytag: member="slu_ddefs.h::dGenXtrue" ref="ebd8d273c58591dc435e1afd4e837d9f" args="(int, int, double *, int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dGenXtrue           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="1a5e04478d6d6e4f714fee3080f5a065"></a><!-- doxytag: member="slu_ddefs.h::dgscon" ref="1a5e04478d6d6e4f714fee3080f5a065" args="(char *, SuperMatrix *, SuperMatrix *, double, double *, SuperLUStat_t *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dgscon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
   Purpose   
   =======</pre><p>
<pre>   DGSCON estimates the reciprocal of the condition number of a general 
   real matrix A, in either the 1-norm or the infinity-norm, using   
   the LU factorization computed by DGETRF.   *</pre><p>
<pre>   An estimate is obtained for norm(inv(A)), and the reciprocal of the   
   condition number is computed as   
      RCOND = 1 / ( norm(A) * norm(inv(A)) ).</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre>    NORM    (input) char*
            Specifies whether the 1-norm condition number or the   
            infinity-norm condition number is required:   
            = '1' or 'O':  1-norm;   
            = 'I':         Infinity-norm.</pre><p>
<pre>    L       (input) SuperMatrix*
            The factor L from the factorization Pr*A*Pc=L*U as computed by
            <a class="el" href="dgstrf_8c.html#9a055ed4d6378cdbbe6ec5c54121968f">dgstrf()</a>. Use compressed row subscripts storage for supernodes,
            i.e., L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU.</pre><p>
<pre>    U       (input) SuperMatrix*
            The factor U from the factorization Pr*A*Pc=L*U as computed by
            <a class="el" href="dgstrf_8c.html#9a055ed4d6378cdbbe6ec5c54121968f">dgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
            Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU.</pre><p>
<pre>    ANORM   (input) double
            If NORM = '1' or 'O', the 1-norm of the original matrix A.   
            If NORM = 'I', the infinity-norm of the original matrix A.</pre><p>
<pre>    RCOND   (output) double*
           The reciprocal of the condition number of the matrix A,   
           computed as RCOND = 1/(norm(A) * norm(inv(A))).</pre><p>
<pre>    INFO    (output) int*
           = 0:  successful exit   
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre><p>
<pre>    ===================================================================== 
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="fba0263dae6d5d3a700e9e7a120d6b87"></a><!-- doxytag: member="slu_ddefs.h::dgsequ" ref="fba0263dae6d5d3a700e9e7a120d6b87" args="(SuperMatrix *, double *, double *, double *, double *, double *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dgsequ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>amax</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose   
   =======</pre><p>
<pre>   DGSEQU computes row and column scalings intended to equilibrate an   
   M-by-N sparse matrix A and reduce its condition number. R returns the row
   scale factors and C the column scale factors, chosen to try to make   
   the largest element in each row and column of the matrix B with   
   elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.</pre><p>
<pre>   R(i) and C(j) are restricted to be between SMLNUM = smallest safe   
   number and BIGNUM = largest safe number.  Use of these scaling   
   factors is not guaranteed to reduce the condition number of A but   
   works well in practice.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre>   A       (input) SuperMatrix*
           The matrix of dimension (A-&gt;nrow, A-&gt;ncol) whose equilibration
           factors are to be computed. The type of A can be:
           Stype = SLU_NC; Dtype = SLU_D; Mtype = SLU_GE.</pre><p>
<pre>   R       (output) double*, size A-&gt;nrow
           If INFO = 0 or INFO &gt; M, R contains the row scale factors   
           for A.</pre><p>
<pre>   C       (output) double*, size A-&gt;ncol
           If INFO = 0,  C contains the column scale factors for A.</pre><p>
<pre>   ROWCND  (output) double*
           If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the   
           smallest R(i) to the largest R(i).  If ROWCND &gt;= 0.1 and   
           AMAX is neither too large nor too small, it is not worth   
           scaling by R.</pre><p>
<pre>   COLCND  (output) double*
           If INFO = 0, COLCND contains the ratio of the smallest   
           C(i) to the largest C(i).  If COLCND &gt;= 0.1, it is not   
           worth scaling by C.</pre><p>
<pre>   AMAX    (output) double*
           Absolute value of largest matrix element.  If AMAX is very   
           close to overflow or very close to underflow, the matrix   
           should be scaled.</pre><p>
<pre>   INFO    (output) int*
           = 0:  successful exit   
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value   
           &gt; 0:  if INFO = i,  and i is   
                 &lt;= A-&gt;nrow:  the i-th row of A is exactly zero   
                 &gt;  A-&gt;ncol:  the (i-M)-th column of A is exactly zero</pre><p>
<pre>   ===================================================================== 
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="424f8b36e210117c4dea0c590e977bb4"></a><!-- doxytag: member="slu_ddefs.h::dgsrfs" ref="424f8b36e210117c4dea0c590e977bb4" args="(trans_t, SuperMatrix *, SuperMatrix *, SuperMatrix *, int *, int *, char *, double *, double *, SuperMatrix *, SuperMatrix *, double *, double *, SuperLUStat_t *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dgsrfs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="slu__util_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>equed</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>berr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
   Purpose   
   =======</pre><p>
<pre>   DGSRFS improves the computed solution to a system of linear   
   equations and provides error bounds and backward error estimates for 
   the solution.</pre><p>
<pre>   If equilibration was performed, the system becomes:
           (diag(R)*A_original*diag(C)) * X = diag(R)*B_original.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre> trans   (input) trans_t
          Specifies the form of the system of equations:
          = NOTRANS: A * X = B  (No transpose)
          = TRANS:   A'* X = B  (Transpose)
          = CONJ:    A**H * X = B  (Conjugate transpose)</pre><p>
<pre>   A       (input) SuperMatrix*
           The original matrix A in the system, or the scaled A if
           equilibration was done. The type of A can be:
           Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_GE.</pre><p>
<pre>   L       (input) SuperMatrix*
	     The factor L from the factorization Pr*A*Pc=L*U. Use
           compressed row subscripts storage for supernodes, 
           i.e., L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU.</pre><p>
<pre>   U       (input) SuperMatrix*
           The factor U from the factorization Pr*A*Pc=L*U as computed by
           <a class="el" href="dgstrf_8c.html#9a055ed4d6378cdbbe6ec5c54121968f">dgstrf()</a>. Use column-wise storage scheme, 
           i.e., U has types: Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU.</pre><p>
<pre>   perm_c  (input) int*, dimension (A-&gt;ncol)
	     Column permutation vector, which defines the 
           permutation matrix Pc; perm_c[i] = j means column i of A is 
           in position j in A*Pc.</pre><p>
<pre>   perm_r  (input) int*, dimension (A-&gt;nrow)
           Row permutation vector, which defines the permutation matrix Pr;
           perm_r[i] = j means row i of A is in position j in Pr*A.</pre><p>
<pre>   equed   (input) Specifies the form of equilibration that was done.
           = 'N': No equilibration.
           = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
           = 'C': Column equilibration, i.e., A was postmultiplied by
                  diag(C).
           = 'B': Both row and column equilibration, i.e., A was replaced 
                  by diag(R)*A*diag(C).</pre><p>
<pre>   R       (input) double*, dimension (A-&gt;nrow)
           The row scale factors for A.
           If equed = 'R' or 'B', A is premultiplied by diag(R).
           If equed = 'N' or 'C', R is not accessed.</pre><p>
<pre>   C       (input) double*, dimension (A-&gt;ncol)
           The column scale factors for A.
           If equed = 'C' or 'B', A is postmultiplied by diag(C).
           If equed = 'N' or 'R', C is not accessed.</pre><p>
<pre>   B       (input) SuperMatrix*
           B has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE.
           The right hand side matrix B.
           if equed = 'R' or 'B', B is premultiplied by diag(R).</pre><p>
<pre>   X       (input/output) SuperMatrix*
           X has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE.
           On entry, the solution matrix X, as computed by <a class="el" href="dgstrs_8c.html#6e3eace519372b7dfcd053e0d3614fc1">dgstrs()</a>.
           On exit, the improved solution matrix X.
           if *equed = 'C' or 'B', X should be premultiplied by diag(C)
               in order to obtain the solution to the original system.</pre><p>
<pre>   FERR    (output) double*, dimension (B-&gt;ncol)   
           The estimated forward error bound for each solution vector   
           X(j) (the j-th column of the solution matrix X).   
           If XTRUE is the true solution corresponding to X(j), FERR(j) 
           is an estimated upper bound for the magnitude of the largest 
           element in (X(j) - XTRUE) divided by the magnitude of the   
           largest element in X(j).  The estimate is as reliable as   
           the estimate for RCOND, and is almost always a slight   
           overestimate of the true error.</pre><p>
<pre>   BERR    (output) double*, dimension (B-&gt;ncol)   
           The componentwise relative backward error of each solution   
           vector X(j) (i.e., the smallest relative change in   
           any element of A or B that makes X(j) an exact solution).</pre><p>
<pre>   stat     (output) SuperLUStat_t*
            Record the statistics on runtime and floating-point operation count.
            See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre>   info    (output) int*   
           = 0:  successful exit   
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre><p>
<pre>    Internal Parameters   
    ===================</pre><p>
<pre>    ITMAX is the maximum number of steps of iterative refinement.</pre><p>
<pre> </pre>     </td>
  </tr>
</table>
<a class="anchor" name="2c8a0856fb555c352ed0f43989d1d71e"></a><!-- doxytag: member="slu_ddefs.h::dgssv" ref="2c8a0856fb555c352ed0f43989d1d71e" args="(superlu_options_t *, SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dgssv           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> DGSSV solves the system of linear equations A*X=B, using the
 LU factorization from DGSTRF. It performs the following steps:</pre><p>
<pre>   1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><p>
<pre>      1.1. Permute the columns of A, forming A*Pc, where Pc
           is a permutation matrix. For more details of this step, 
           see <a class="el" href="sp__preorder_8c.html">sp_preorder.c</a>.</pre><p>
<pre>      1.2. Factor A as Pr*A*Pc=L*U with the permutation Pr determined
           by Gaussian elimination with partial pivoting.
           L is unit lower triangular with offdiagonal entries
           bounded by 1 in magnitude, and U is upper triangular.</pre><p>
<pre>      1.3. Solve the system of equations A*X=B using the factored
           form of A.</pre><p>
<pre>   2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the
      above algorithm to the transpose of A:</pre><p>
<pre>      2.1. Permute columns of transpose(A) (rows of A),
           forming transpose(A)*Pc, where Pc is a permutation matrix. 
           For more details of this step, see <a class="el" href="sp__preorder_8c.html">sp_preorder.c</a>.</pre><p>
<pre>      2.2. Factor A as Pr*transpose(A)*Pc=L*U with the permutation Pr
           determined by Gaussian elimination with partial pivoting.
           L is unit lower triangular with offdiagonal entries
           bounded by 1 in magnitude, and U is upper triangular.</pre><p>
<pre>      2.3. Solve the system of equations A*X=B using the factored
           form of A.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed and how the
         system will be solved.</pre><p>
<pre> A       (input) SuperMatrix*
         Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
         of linear equations is A-&gt;nrow. Currently, the type of A can be:
         Stype = SLU_NC or SLU_NR; Dtype = SLU_D; Mtype = SLU_GE.
         In the future, more general A may be handled.</pre><p>
<pre> perm_c  (input/output) int*
         If A-&gt;Stype = SLU_NC, column permutation vector of size A-&gt;ncol
         which defines the permutation matrix Pc; perm_c[i] = j means 
         column i of A is in position j in A*Pc.
         If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow
         which describes permutation of columns of transpose(A) 
         (rows of A) as described above.</pre><p>
<pre>         If options-&gt;ColPerm = MY_PERMC or options-&gt;Fact = SamePattern or
            options-&gt;Fact = SamePattern_SameRowPerm, it is an input argument.
            On exit, perm_c may be overwritten by the product of the input
            perm_c and a permutation that postorders the elimination tree
            of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
            is already in postorder.
         Otherwise, it is an output argument.</pre><p>
<pre> perm_r  (input/output) int*
         If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
         which defines the permutation matrix Pr, and is determined 
         by partial pivoting.  perm_r[i] = j means row i of A is in 
         position j in Pr*A.
         If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
         determines permutation of rows of transpose(A)
         (columns of A) as described above.</pre><p>
<pre>         If options-&gt;RowPerm = MY_PERMR or
            options-&gt;Fact = SamePattern_SameRowPerm, perm_r is an
            input argument.
         otherwise it is an output argument.</pre><p>
<pre> L       (output) SuperMatrix*
         The factor L from the factorization 
             Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses compressed row subscripts storage for supernodes, i.e.,
         L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU.</pre><p>
<pre> U       (output) SuperMatrix*
	   The factor U from the factorization 
             Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses column-wise storage scheme, i.e., U has types:
         Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU.</pre><p>
<pre> B       (input/output) SuperMatrix*
         B has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE.
         On entry, the right hand side matrix.
         On exit, the solution matrix if info = 0;</pre><p>
<pre> stat   (output) SuperLUStat_t*
        Record the statistics on runtime and floating-point operation count.
        See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
	   = 0: successful exit
         &gt; 0: if info = i, and i is
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                been completed, but the factor U is exactly singular,
                so the solution could not be computed.
             &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                failure occurred, plus A-&gt;ncol.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="55ccb099a318043965a941a7fd8cb095"></a><!-- doxytag: member="slu_ddefs.h::dgssvx" ref="55ccb099a318043965a941a7fd8cb095" args="(superlu_options_t *, SuperMatrix *, int *, int *, int *, char *, double *, double *, SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, SuperMatrix *, double *, double *, double *, double *, mem_usage_t *, SuperLUStat_t *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dgssvx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>etree</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>equed</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>recip_pivot_growth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>berr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>mem_usage</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> DGSSVX solves the system of linear equations A*X=B or A'*X=B, using
 the LU factorization from <a class="el" href="dgstrf_8c.html#9a055ed4d6378cdbbe6ec5c54121968f">dgstrf()</a>. Error bounds on the solution and
 a condition estimate are also provided. It performs the following steps:</pre><p>
<pre>   1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><p>
<pre>      1.1. If options-&gt;Equil = YES, scaling factors are computed to
           equilibrate the system:
           options-&gt;Trans = NOTRANS:
               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
           options-&gt;Trans = TRANS:
               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
           options-&gt;Trans = CONJ:
               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
           Whether or not the system will be equilibrated depends on the
           scaling of the matrix A, but if equilibration is used, A is
           overwritten by diag(R)*A*diag(C) and B by diag(R)*B
           (if options-&gt;Trans=NOTRANS) or diag(C)*B (if options-&gt;Trans
           = TRANS or CONJ).</pre><p>
<pre>      1.2. Permute columns of A, forming A*Pc, where Pc is a permutation
           matrix that usually preserves sparsity.
           For more details of this step, see <a class="el" href="sp__preorder_8c.html">sp_preorder.c</a>.</pre><p>
<pre>      1.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
           factor the matrix A (after equilibration if options-&gt;Equil = YES)
           as Pr*A*Pc = L*U, with Pr determined by partial pivoting.</pre><p>
<pre>      1.4. Compute the reciprocal pivot growth factor.</pre><p>
<pre>      1.5. If some U(i,i) = 0, so that U is exactly singular, then the
           routine returns with info = i. Otherwise, the factored form of 
           A is used to estimate the condition number of the matrix A. If
           the reciprocal of the condition number is less than machine
           precision, info = A-&gt;ncol+1 is returned as a warning, but the
           routine still goes on to solve for X and computes error bounds
           as described below.</pre><p>
<pre>      1.6. The system of equations is solved for X using the factored form
           of A.</pre><p>
<pre>      1.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
           applied to improve the computed solution matrix and calculate
           error bounds and backward error estimates for it.</pre><p>
<pre>      1.8. If equilibration was used, the matrix X is premultiplied by
           diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
           (if options-&gt;Trans = TRANS or CONJ) so that it solves the
           original system before equilibration.</pre><p>
<pre>   2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the above algorithm
      to the transpose of A:</pre><p>
<pre>      2.1. If options-&gt;Equil = YES, scaling factors are computed to
           equilibrate the system:
           options-&gt;Trans = NOTRANS:
               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
           options-&gt;Trans = TRANS:
               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
           options-&gt;Trans = CONJ:
               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
           Whether or not the system will be equilibrated depends on the
           scaling of the matrix A, but if equilibration is used, A' is
           overwritten by diag(R)*A'*diag(C) and B by diag(R)*B 
           (if trans='N') or diag(C)*B (if trans = 'T' or 'C').</pre><p>
<pre>      2.2. Permute columns of transpose(A) (rows of A), 
           forming transpose(A)*Pc, where Pc is a permutation matrix that 
           usually preserves sparsity.
           For more details of this step, see <a class="el" href="sp__preorder_8c.html">sp_preorder.c</a>.</pre><p>
<pre>      2.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
           factor the transpose(A) (after equilibration if 
           options-&gt;Fact = YES) as Pr*transpose(A)*Pc = L*U with the
           permutation Pr determined by partial pivoting.</pre><p>
<pre>      2.4. Compute the reciprocal pivot growth factor.</pre><p>
<pre>      2.5. If some U(i,i) = 0, so that U is exactly singular, then the
           routine returns with info = i. Otherwise, the factored form 
           of transpose(A) is used to estimate the condition number of the
           matrix A. If the reciprocal of the condition number
           is less than machine precision, info = A-&gt;nrow+1 is returned as
           a warning, but the routine still goes on to solve for X and
           computes error bounds as described below.</pre><p>
<pre>      2.6. The system of equations is solved for X using the factored form
           of transpose(A).</pre><p>
<pre>      2.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
           applied to improve the computed solution matrix and calculate
           error bounds and backward error estimates for it.</pre><p>
<pre>      2.8. If equilibration was used, the matrix X is premultiplied by
           diag(C) (if options-&gt;Trans = NOTRANS) or diag(R) 
           (if options-&gt;Trans = TRANS or CONJ) so that it solves the
           original system before equilibration.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed and how the
         system will be solved.</pre><p>
<pre> A       (input/output) SuperMatrix*
         Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
         of the linear equations is A-&gt;nrow. Currently, the type of A can be:
         Stype = SLU_NC or SLU_NR, Dtype = SLU_D, Mtype = SLU_GE.
         In the future, more general A may be handled.</pre><p>
<pre>         On entry, If options-&gt;Fact = FACTORED and equed is not 'N', 
         then A must have been equilibrated by the scaling factors in
         R and/or C.  
         On exit, A is not modified if options-&gt;Equil = NO, or if 
         options-&gt;Equil = YES but equed = 'N' on exit.
         Otherwise, if options-&gt;Equil = YES and equed is not 'N',
         A is scaled as follows:
         If A-&gt;Stype = SLU_NC:
           equed = 'R':  A := diag(R) * A
           equed = 'C':  A := A * diag(C)
           equed = 'B':  A := diag(R) * A * diag(C).
         If A-&gt;Stype = SLU_NR:
           equed = 'R':  transpose(A) := diag(R) * transpose(A)
           equed = 'C':  transpose(A) := transpose(A) * diag(C)
           equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C).</pre><p>
<pre> perm_c  (input/output) int*
	   If A-&gt;Stype = SLU_NC, Column permutation vector of size A-&gt;ncol,
         which defines the permutation matrix Pc; perm_c[i] = j means
         column i of A is in position j in A*Pc.
         On exit, perm_c may be overwritten by the product of the input
         perm_c and a permutation that postorders the elimination tree
         of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
         is already in postorder.</pre><p>
<pre>         If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow,
         which describes permutation of columns of transpose(A) 
         (rows of A) as described above.</pre><p>
<pre> perm_r  (input/output) int*
         If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
         which defines the permutation matrix Pr, and is determined
         by partial pivoting.  perm_r[i] = j means row i of A is in 
         position j in Pr*A.</pre><p>
<pre>         If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
         determines permutation of rows of transpose(A)
         (columns of A) as described above.</pre><p>
<pre>         If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
         will try to use the input perm_r, unless a certain threshold
         criterion is violated. In that case, perm_r is overwritten by a
         new permutation determined by partial pivoting or diagonal
         threshold pivoting.
         Otherwise, perm_r is output argument.</pre><p>
<pre> etree   (input/output) int*,  dimension (A-&gt;ncol)
         Elimination tree of Pc'*A'*A*Pc.
         If options-&gt;Fact != FACTORED and options-&gt;Fact != DOFACT,
         etree is an input argument, otherwise it is an output argument.
         Note: etree is a vector of parent pointers for a forest whose
         vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><p>
<pre> equed   (input/output) char*
         Specifies the form of equilibration that was done.
         = 'N': No equilibration.
         = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
         = 'C': Column equilibration, i.e., A was postmultiplied by diag(C).
         = 'B': Both row and column equilibration, i.e., A was replaced 
                by diag(R)*A*diag(C).
         If options-&gt;Fact = FACTORED, equed is an input argument,
         otherwise it is an output argument.</pre><p>
<pre> R       (input/output) double*, dimension (A-&gt;nrow)
         The row scale factors for A or transpose(A).
         If equed = 'R' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
             (if A-&gt;Stype = SLU_NR) is multiplied on the left by diag(R).
         If equed = 'N' or 'C', R is not accessed.
         If options-&gt;Fact = FACTORED, R is an input argument,
             otherwise, R is output.
         If options-&gt;zFact = FACTORED and equed = 'R' or 'B', each element
             of R must be positive.</pre><p>
<pre> C       (input/output) double*, dimension (A-&gt;ncol)
         The column scale factors for A or transpose(A).
         If equed = 'C' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
             (if A-&gt;Stype = SLU_NR) is multiplied on the right by diag(C).
         If equed = 'N' or 'R', C is not accessed.
         If options-&gt;Fact = FACTORED, C is an input argument,
             otherwise, C is output.
         If options-&gt;Fact = FACTORED and equed = 'C' or 'B', each element
             of C must be positive.</pre><p>
<pre> L       (output) SuperMatrix*
	   The factor L from the factorization
             Pr*A*Pc=L*U              (if A-&gt;Stype SLU_= NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses compressed row subscripts storage for supernodes, i.e.,
         L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU.</pre><p>
<pre> U       (output) SuperMatrix*
	   The factor U from the factorization
             Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses column-wise storage scheme, i.e., U has types:
         Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU.</pre><p>
<pre> work    (workspace/output) void*, size (lwork) (in bytes)
         User supplied workspace, should be large enough
         to hold data structures for factors L and U.
         On exit, if fact is not 'F', L and U point to this array.</pre><p>
<pre> lwork   (input) int
         Specifies the size of work array in bytes.
         = 0:  allocate space internally by system malloc;
         &gt; 0:  use user-supplied work array of length lwork in bytes,
               returns error if space runs out.
         = -1: the routine guesses the amount of space needed without
               performing the factorization, and returns it in
               mem_usage-&gt;total_needed; no other side effects.</pre><p>
<pre>         See argument 'mem_usage' for memory usage statistics.</pre><p>
<pre> B       (input/output) SuperMatrix*
         B has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE.
         On entry, the right hand side matrix.
         If B-&gt;ncol = 0, only LU decomposition is performed, the triangular
                         solve is skipped.
         On exit,
            if equed = 'N', B is not modified; otherwise
            if A-&gt;Stype = SLU_NC:
               if options-&gt;Trans = NOTRANS and equed = 'R' or 'B',
                  B is overwritten by diag(R)*B;
               if options-&gt;Trans = TRANS or CONJ and equed = 'C' of 'B',
                  B is overwritten by diag(C)*B;
            if A-&gt;Stype = SLU_NR:
               if options-&gt;Trans = NOTRANS and equed = 'C' or 'B',
                  B is overwritten by diag(C)*B;
               if options-&gt;Trans = TRANS or CONJ and equed = 'R' of 'B',
                  B is overwritten by diag(R)*B.</pre><p>
<pre> X       (output) SuperMatrix*
         X has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE. 
         If info = 0 or info = A-&gt;ncol+1, X contains the solution matrix
         to the original system of equations. Note that A and B are modified
         on exit if equed is not 'N', and the solution to the equilibrated
         system is inv(diag(C))*X if options-&gt;Trans = NOTRANS and
         equed = 'C' or 'B', or inv(diag(R))*X if options-&gt;Trans = 'T' or 'C'
         and equed = 'R' or 'B'.</pre><p>
<pre> recip_pivot_growth (output) double*
         The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ).
         The infinity norm is used. If recip_pivot_growth is much less
         than 1, the stability of the LU factorization could be poor.</pre><p>
<pre> rcond   (output) double*
         The estimate of the reciprocal condition number of the matrix A
         after equilibration (if done). If rcond is less than the machine
         precision (in particular, if rcond = 0), the matrix is singular
         to working precision. This condition is indicated by a return
         code of info &gt; 0.</pre><p>
<pre> FERR    (output) double*, dimension (B-&gt;ncol)   
         The estimated forward error bound for each solution vector   
         X(j) (the j-th column of the solution matrix X).   
         If XTRUE is the true solution corresponding to X(j), FERR(j) 
         is an estimated upper bound for the magnitude of the largest 
         element in (X(j) - XTRUE) divided by the magnitude of the   
         largest element in X(j).  The estimate is as reliable as   
         the estimate for RCOND, and is almost always a slight   
         overestimate of the true error.
         If options-&gt;IterRefine = NOREFINE, ferr = 1.0.</pre><p>
<pre> BERR    (output) double*, dimension (B-&gt;ncol)
         The componentwise relative backward error of each solution   
         vector X(j) (i.e., the smallest relative change in   
         any element of A or B that makes X(j) an exact solution).
         If options-&gt;IterRefine = NOREFINE, berr = 1.0.</pre><p>
<pre> mem_usage (output) mem_usage_t*
         Record the memory usage statistics, consisting of following fields:<ul>
<li>for_lu (float)
           The amount of space used in bytes for L data structures.</li><li>total_needed (float)
           The amount of space needed in bytes to perform factorization.</li><li>expansions (int)
           The number of memory expansions during the LU factorization.</li></ul>
</pre><p>
<pre> stat   (output) SuperLUStat_t*
        Record the statistics on runtime and floating-point operation count.
        See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
         = 0: successful exit   
         &lt; 0: if info = -i, the i-th argument had an illegal value   
         &gt; 0: if info = i, and i is   
              &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has   
                    been completed, but the factor U is exactly   
                    singular, so the solution and error bounds   
                    could not be computed.   
              = A-&gt;ncol+1: U is nonsingular, but RCOND is less than machine
                    precision, meaning that the matrix is singular to
                    working precision. Nevertheless, the solution and
                    error bounds are computed because there are a number
                    of situations where the computed solution can be more
                    accurate than the value of RCOND would suggest.   
              &gt; A-&gt;ncol+1: number of bytes allocated when memory allocation
                    failure occurred, plus A-&gt;ncol.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="0bd7d78413e339698b01a44765db04c3"></a><!-- doxytag: member="slu_ddefs.h::dgstrf" ref="0bd7d78413e339698b01a44765db04c3" args="(superlu_options_t *, SuperMatrix *, double, int, int, int *, void *, int, int *, int *, SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dgstrf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>drop_tol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>relax</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>etree</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> DGSTRF computes an LU factorization of a general sparse m-by-n
 matrix A using partial pivoting with row interchanges.
 The factorization has the form
     Pr * A = L * U
 where Pr is a row permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper 
 triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><p>
<pre> See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed.</pre><p>
<pre> A        (input) SuperMatrix*
	    Original matrix A, permuted by columns, of dimension
          (A-&gt;nrow, A-&gt;ncol). The type of A can be:
          Stype = SLU_NCP; Dtype = SLU_D; Mtype = SLU_GE.</pre><p>
<pre> drop_tol (input) double (NOT IMPLEMENTED)
	    Drop tolerance parameter. At step j of the Gaussian elimination,
          if <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>/(max_i <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>) &lt; drop_tol, drop entry A_ij.
          0 &lt;= drop_tol &lt;= 1. The default value of drop_tol is 0.</pre><p>
<pre> relax    (input) int
          To control degree of relaxing supernodes. If the number
          of nodes (columns) in a subtree of the elimination tree is less
          than relax, this subtree is considered as one supernode,
          regardless of the row structures of those columns.</pre><p>
<pre> panel_size (input) int
          A panel consists of at most panel_size consecutive columns.</pre><p>
<pre> etree    (input) int*, dimension (A-&gt;ncol)
          Elimination tree of A'*A.
          Note: etree is a vector of parent pointers for a forest whose
          vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
          On input, the columns of A should be permuted so that the
          etree is in a certain postorder.</pre><p>
<pre> work     (input/output) void*, size (lwork) (in bytes)
          User-supplied work space and space for the output data structures.
          Not referenced if lwork = 0;</pre><p>
<pre> lwork   (input) int
         Specifies the size of work array in bytes.
         = 0:  allocate space internally by system malloc;
         &gt; 0:  use user-supplied work array of length lwork in bytes,
               returns error if space runs out.
         = -1: the routine guesses the amount of space needed without
               performing the factorization, and returns it in
               *info; no other side effects.</pre><p>
<pre> perm_c   (input) int*, dimension (A-&gt;ncol)
	    Column permutation vector, which defines the 
          permutation matrix Pc; perm_c[i] = j means column i of A is 
          in position j in A*Pc.
          When searching for diagonal, perm_c[*] is applied to the
          row subscripts of A, so that diagonal threshold pivoting
          can find the diagonal of A, rather than that of A*Pc.</pre><p>
<pre> perm_r   (input/output) int*, dimension (A-&gt;nrow)
          Row permutation vector which defines the permutation matrix Pr,
          perm_r[i] = j means row i of A is in position j in Pr*A.
          If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
             will try to use the input perm_r, unless a certain threshold
             criterion is violated. In that case, perm_r is overwritten by
             a new permutation determined by partial pivoting or diagonal
             threshold pivoting.
          Otherwise, perm_r is output argument;</pre><p>
<pre> L        (output) SuperMatrix*
          The factor L from the factorization Pr*A=L*U; use compressed row 
          subscripts storage for supernodes, i.e., L has type: 
          Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU.</pre><p>
<pre> U        (output) SuperMatrix*
	    The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
          storage scheme, i.e., U has types: Stype = SLU_NC, 
          Dtype = SLU_D, Mtype = SLU_TRU.</pre><p>
<pre> stat     (output) SuperLUStat_t*
          Record the statistics on runtime and floating-point operation count.
          See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info     (output) int*
          = 0: successful exit
          &lt; 0: if info = -i, the i-th argument had an illegal value
          &gt; 0: if info = i, and i is
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                been completed, but the factor U is exactly singular,
                and division by zero will occur if it is used to solve a
                system of equations.
             &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                failure occurred, plus A-&gt;ncol. If lwork = -1, it is
                the estimated amount of space needed, plus A-&gt;ncol.</pre><p>
<pre> ======================================================================</pre><p>
<pre> Local Working Arrays: 
 ======================
   m = number of rows in the matrix
   n = number of columns in the matrix</pre><p>
<pre>   xprune[0:n-1]: xprune[*] points to locations in subscript 
	vector lsub[*]. For column i, xprune[i] denotes the point where 
	structural pruning begins. I.e. only xlsub[i],..,xprune[i]-1 need 
	to be traversed for symbolic factorization.</pre><p>
<pre>   marker[0:3*m-1]: marker[i] = j means that node i has been 
	reached when working on column j.
	Storage: relative to original row subscripts
	NOTE: There are 3 of them: marker/marker1 are used for panel dfs, 
	      see <a class="el" href="dpanel__dfs_8c.html">dpanel_dfs.c</a>; marker2 is used for inner-factorization,
            see <a class="el" href="dcolumn__dfs_8c.html">dcolumn_dfs.c</a>.</pre><p>
<pre>   parent[0:m-1]: parent vector used during dfs
      Storage: relative to new row subscripts</pre><p>
<pre>   xplore[0:m-1]: xplore[i] gives the location of the next (dfs) 
	unexplored neighbor of i in lsub[*]</pre><p>
<pre>   segrep[0:nseg-1]: contains the list of supernodal representatives
	in topological order of the dfs. A supernode representative is the 
	last column of a supernode.
      The maximum size of segrep[] is n.</pre><p>
<pre>   repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a 
	supernodal representative r, repfnz[r] is the location of the first 
	nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
	indicates the supernode r has been explored.
	NOTE: There are W of them, each used for one column of a panel.</pre><p>
<pre>   panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below 
      the panel diagonal. These are filled in during <a class="el" href="dpanel__dfs_8c.html#2a809488b87d2c1a9b2a574b726e8517">dpanel_dfs()</a>, and are
      used later in the inner LU factorization within the panel.
	panel_lsub[]/dense[] pair forms the SPA data structure.
	NOTE: There are W of them.</pre><p>
<pre>   dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
	    	   NOTE: there are W of them.</pre><p>
<pre>   tempv[0:*]: real temporary used for dense numeric kernels;
	The size of this array is defined by <a class="el" href="slu__util_8h.html#06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__ddefs_8h.html">slu_ddefs.h</a>.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="8d42744f59d84a50b19aa4c28cf7aded"></a><!-- doxytag: member="slu_ddefs.h::dgstrs" ref="8d42744f59d84a50b19aa4c28cf7aded" args="(trans_t, SuperMatrix *, SuperMatrix *, int *, int *, SuperMatrix *, SuperLUStat_t *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dgstrs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="slu__util_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> DGSTRS solves a system of linear equations A*X=B or A'*X=B
 with A sparse and B dense, using the LU factorization computed by
 DGSTRF.</pre><p>
<pre> See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> trans   (input) trans_t
          Specifies the form of the system of equations:
          = NOTRANS: A * X = B  (No transpose)
          = TRANS:   A'* X = B  (Transpose)
          = CONJ:    A**H * X = B  (Conjugate transpose)</pre><p>
<pre> L       (input) SuperMatrix*
         The factor L from the factorization Pr*A*Pc=L*U as computed by
         <a class="el" href="dgstrf_8c.html#9a055ed4d6378cdbbe6ec5c54121968f">dgstrf()</a>. Use compressed row subscripts storage for supernodes,
         i.e., L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU.</pre><p>
<pre> U       (input) SuperMatrix*
         The factor U from the factorization Pr*A*Pc=L*U as computed by
         <a class="el" href="dgstrf_8c.html#9a055ed4d6378cdbbe6ec5c54121968f">dgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
         Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU.</pre><p>
<pre> perm_c  (input) int*, dimension (L-&gt;ncol)
	   Column permutation vector, which defines the 
         permutation matrix Pc; perm_c[i] = j means column i of A is 
         in position j in A*Pc.</pre><p>
<pre> perm_r  (input) int*, dimension (L-&gt;nrow)
         Row permutation vector, which defines the permutation matrix Pr; 
         perm_r[i] = j means row i of A is in position j in Pr*A.</pre><p>
<pre> B       (input/output) SuperMatrix*
         B has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE.
         On entry, the right hand side matrix.
         On exit, the solution matrix if info = 0;</pre><p>
<pre> stat     (output) SuperLUStat_t*
          Record the statistics on runtime and floating-point operation count.
          See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
 	   = 0: successful exit
	   &lt; 0: if info = -i, the i-th argument had an illegal value
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="d778c065ce9768d1f971d8a556752f11"></a><!-- doxytag: member="slu_ddefs.h::dinf_norm_error" ref="d778c065ce9768d1f971d8a556752f11" args="(int, SuperMatrix *, double *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dinf_norm_error           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="7c3a821ed273808f662ddd41be6c6c97"></a><!-- doxytag: member="slu_ddefs.h::dlaqgs" ref="7c3a821ed273808f662ddd41be6c6c97" args="(SuperMatrix *, double *, double *, double, double, double, char *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dlaqgs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>amax</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>equed</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
   Purpose   
   =======</pre><p>
<pre>   DLAQGS equilibrates a general sparse M by N matrix A using the row and   
   scaling factors in the vectors R and C.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre>   A       (input/output) SuperMatrix*
           On exit, the equilibrated matrix.  See EQUED for the form of 
           the equilibrated matrix. The type of A can be:
	    Stype = NC; Dtype = SLU_D; Mtype = GE.</pre><p>
<pre>   R       (input) double*, dimension (A-&gt;nrow)
           The row scale factors for A.</pre><p>
<pre>   C       (input) double*, dimension (A-&gt;ncol)
           The column scale factors for A.</pre><p>
<pre>   ROWCND  (input) double
           Ratio of the smallest R(i) to the largest R(i).</pre><p>
<pre>   COLCND  (input) double
           Ratio of the smallest C(i) to the largest C(i).</pre><p>
<pre>   AMAX    (input) double
           Absolute value of largest matrix entry.</pre><p>
<pre>   EQUED   (output) char*
           Specifies the form of equilibration that was done.   
           = 'N':  No equilibration   
           = 'R':  Row equilibration, i.e., A has been premultiplied by  
                   diag(R).   
           = 'C':  Column equilibration, i.e., A has been postmultiplied  
                   by diag(C).   
           = 'B':  Both row and column equilibration, i.e., A has been
                   replaced by diag(R) * A * diag(C).</pre><p>
<pre>   Internal Parameters   
   ===================</pre><p>
<pre>   THRESH is a threshold value used to decide if row or column scaling   
   should be done based on the ratio of the row or column scaling   
   factors.  If ROWCND &lt; THRESH, row scaling is done, and if   
   COLCND &lt; THRESH, column scaling is done.</pre><p>
<pre>   LARGE and SMALL are threshold values used to decide if row scaling   
   should be done based on the absolute size of the largest matrix   
   element.  If AMAX &gt; LARGE or AMAX &lt; SMALL, row scaling is done.</pre><p>
<pre>   ===================================================================== 
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="12a4221c734db9540566cb1386a2e6fc"></a><!-- doxytag: member="slu_ddefs.h::dLUMemInit" ref="12a4221c734db9540566cb1386a2e6fc" args="(fact_t, void *, int, int, int, int, int, SuperMatrix *, SuperMatrix *, GlobalLU_t *, int **, double **)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dLUMemInit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="slu__util_8h.html#c785c8235480e5cfef9848d89c047c0a">fact_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fact</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>annz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap> <em>dwork</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 For those unpredictable size, make a guess as FILL * nnz(A).
 Return value:
     If lwork = -1, return the estimated amount of space required, plus n;
     otherwise, return the amount of space actually allocated when
     memory allocation failure occurred.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="4cc8cb916b6bf5f2238c374aa7339f4c"></a><!-- doxytag: member="slu_ddefs.h::dLUMemXpand" ref="4cc8cb916b6bf5f2238c374aa7339f4c" args="(int, int, MemType, int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dLUMemXpand           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>next</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="slu__util_8h.html#bd31f838aefffa46191d0d7dc36a96b2">MemType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mem_type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Return value:   0 - successful return
               &gt; 0 - number of bytes allocated when run out of space
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="e7976837d1936a3150abf5dd62f0c211"></a><!-- doxytag: member="slu_ddefs.h::dLUWorkFree" ref="e7976837d1936a3150abf5dd62f0c211" args="(int *, double *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dLUWorkFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a7bf96909e8e3579499f46a84b28d9df"></a><!-- doxytag: member="slu_ddefs.h::dmemory_usage" ref="a7bf96909e8e3579499f46a84b28d9df" args="(const int, const int, const int, const int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dmemory_usage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="2b7be732f4d725dd35799d772473625e"></a><!-- doxytag: member="slu_ddefs.h::doubleCalloc" ref="2b7be732f4d725dd35799d772473625e" args="(int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double* doubleCalloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="47c4cf79f8c6305147a70de6da2696ac"></a><!-- doxytag: member="slu_ddefs.h::doubleMalloc" ref="47c4cf79f8c6305147a70de6da2696ac" args="(int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double* doubleMalloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="22cfb6f57857cc7cb3d853ee5467656f"></a><!-- doxytag: member="slu_ddefs.h::dpanel_bmod" ref="22cfb6f57857cc7cb3d853ee5467656f" args="(const int, const int, const int, const int, double *, double *, int *, int *, GlobalLU_t *, SuperLUStat_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dpanel_bmod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>dense</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre>    Performs numeric block updates (sup-panel) in topological order.
    It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
    Special processing on the supernodal portion of L[*,j]</pre><p>
<pre>    Before entering this routine, the original nonzeros in the panel 
    were already copied into the spa[m,w].</pre><p>
<pre>    Updated/Output parameters-
    dense[0:m-1,w]: L[*,j:j+w-1] and U[*,j:j+w-1] are returned 
    collectively in the m-by-w vector dense[*]. 
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="ca83bf1fa16a64ea2ee575574a8bb969"></a><!-- doxytag: member="slu_ddefs.h::dpanel_dfs" ref="ca83bf1fa16a64ea2ee575574a8bb969" args="(const int, const int, const int, SuperMatrix *, int *, int *, double *, int *, int *, int *, int *, int *, int *, int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dpanel_dfs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>dense</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre>   Performs a symbolic factorization on a panel of columns [jcol, jcol+w).</pre><p>
<pre>   A supernode representative is the last column of a supernode.
   The nonzeros in U[*,j] are segments that end at supernodal
   representatives.</pre><p>
<pre>   The routine returns one list of the supernodal representatives
   in topological order of the dfs that generates them. This list is
   a superset of the topological order of each individual column within
   the panel. 
   The location of the first nonzero in each supernodal segment
   (supernodal entry location) is also returned. Each column has a 
   separate list for this purpose.</pre><p>
<pre>   Two marker arrays are used for dfs:
     marker[i] == jj, if i was visited during dfs of current column jj;
     marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</pre><p>
<pre>   marker: A-row --&gt; A-row/col (0/1)
   repfnz: SuperA-col --&gt; PA-row
   parent: SuperA-col --&gt; SuperA-col
   xplore: SuperA-col --&gt; index to L-structure
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="2c1536c187133a8a8ea5d856a222eec5"></a><!-- doxytag: member="slu_ddefs.h::dPivotGrowth" ref="2c1536c187133a8a8ea5d856a222eec5" args="(int, SuperMatrix *, int *, SuperMatrix *, SuperMatrix *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double dPivotGrowth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> Compute the reciprocal pivot growth factor of the leading ncols columns
 of the matrix, using the formula:
     min_j ( max_i(<a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>) / max_i(<a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(U_ij)</a>) )</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> ncols    (input) int
          The number of columns of matrices A, L and U.</pre><p>
<pre> A        (input) SuperMatrix*
	    Original matrix A, permuted by columns, of dimension
          (A-&gt;nrow, A-&gt;ncol). The type of A can be:
          Stype = NC; Dtype = SLU_D; Mtype = GE.</pre><p>
<pre> L        (output) SuperMatrix*
          The factor L from the factorization Pr*A=L*U; use compressed row 
          subscripts storage for supernodes, i.e., L has type: 
          Stype = SC; Dtype = SLU_D; Mtype = TRLU.</pre><p>
<pre> U        (output) SuperMatrix*
	    The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
          storage scheme, i.e., U has types: Stype = NC;
          Dtype = SLU_D; Mtype = TRU.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="09624f0c44de80ee2731e44a333ee01c"></a><!-- doxytag: member="slu_ddefs.h::dpivotL" ref="09624f0c44de80ee2731e44a333ee01c" args="(const int, const double, int *, int *, int *, int *, int *, GlobalLU_t *, SuperLUStat_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dpivotL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>usepr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>iperm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>iperm_c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======
   Performs the numerical pivoting on the current column of L,
   and the CDIV operation.</pre><p>
<pre>   Pivot policy:
   (1) Compute thresh = u * max_(i&gt;=j) <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>;
   (2) IF user specifies pivot row k and <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_kj)</a> &gt;= thresh THEN
           pivot row = k;
       ELSE IF <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_jj)</a> &gt;= thresh THEN
           pivot row = j;
       ELSE
           pivot row = m;</pre><p>
<pre>   Note: If you absolutely want to use a given pivot order, then set u=0.0.</pre><p>
<pre>   Return value: 0      success;
                 i &gt; 0  U(i,i) is exactly zero.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="4908a093c1b9d8d96e3fbba6c29673c1"></a><!-- doxytag: member="slu_ddefs.h::dPrint_CompCol_Matrix" ref="4908a093c1b9d8d96e3fbba6c29673c1" args="(char *, SuperMatrix *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dPrint_CompCol_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="d440b7616886349fe2cde5ac490b0f7d"></a><!-- doxytag: member="slu_ddefs.h::dPrint_Dense_Matrix" ref="d440b7616886349fe2cde5ac490b0f7d" args="(char *, SuperMatrix *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dPrint_Dense_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="d6acd040a093d5858b9b77d347be954c"></a><!-- doxytag: member="slu_ddefs.h::dPrint_SuperNode_Matrix" ref="d6acd040a093d5858b9b77d347be954c" args="(char *, SuperMatrix *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dPrint_SuperNode_Matrix           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="98c8e37fbd3e285de80ae5ebc633c64a"></a><!-- doxytag: member="slu_ddefs.h::dpruneL" ref="98c8e37fbd3e285de80ae5ebc633c64a" args="(const int, const int *, const int, const int, const int *, const int *, int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dpruneL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int *&nbsp;</td>
          <td class="mdname" nowrap> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int *&nbsp;</td>
          <td class="mdname" nowrap> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int *&nbsp;</td>
          <td class="mdname" nowrap> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======
   Prunes the L-structure of supernodes whose L-structure
   contains the current pivot row "pivrow"
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="a28191998cfaddc30d4728535a39d996"></a><!-- doxytag: member="slu_ddefs.h::dQuerySpace" ref="a28191998cfaddc30d4728535a39d996" args="(SuperMatrix *, SuperMatrix *, mem_usage_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dQuerySpace           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>mem_usage</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 mem_usage consists of the following fields:<ul>
<li>for_lu (float)
      The amount of space used in bytes for the L data structures.</li><li>total_needed (float)
      The amount of space needed in bytes to perform factorization.</li><li>expansions (int)
      Number of memory expansions during the LU factorization.
 
</li></ul>
</pre>    </td>
  </tr>
</table>
<a class="anchor" name="be5e29734eb193fdda83f02fbb72a60a"></a><!-- doxytag: member="slu_ddefs.h::dreadhb" ref="be5e29734eb193fdda83f02fbb72a60a" args="(int *, int *, int *, double **, int **, int **)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dreadhb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="efc4e420b7fa27a770b4b9db6ba5cfc4"></a><!-- doxytag: member="slu_ddefs.h::dreadmt" ref="efc4e420b7fa27a770b4b9db6ba5cfc4" args="(int *, int *, int *, double **, int **, int **)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dreadmt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="6248d2471a710335359db300b35c5066"></a><!-- doxytag: member="slu_ddefs.h::dSetRWork" ref="6248d2471a710335359db300b35c5066" args="(int, int, double *, double **, double **)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void dSetRWork           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="289847afa67421491f96367c7f2fe90f"></a><!-- doxytag: member="slu_ddefs.h::dsnode_bmod" ref="289847afa67421491f96367c7f2fe90f" args="(const int, const int, const int, double *, double *, GlobalLU_t *, SuperLUStat_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dsnode_bmod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b0fe8232652578797bee690fcd8adfd0"></a><!-- doxytag: member="slu_ddefs.h::dsnode_dfs" ref="b0fe8232652578797bee690fcd8adfd0" args="(const int, const int, const int *, const int *, const int *, int *, int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int dsnode_dfs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>kcol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int *&nbsp;</td>
          <td class="mdname" nowrap> <em>asub</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xa_begin</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xa_end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Glu</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======
    <a class="el" href="dsnode__dfs_8c.html#80b831678c233741661d8386d8736da1">dsnode_dfs()</a> - Determine the union of the row structures of those 
    columns within the relaxed snode.
    Note: The relaxed snodes are leaves of the supernodal etree, therefore, 
    the portion outside the rectangular supernode must be zero.</pre><p>
<pre> Return value
 ============
     0   success;
    &gt;0   number of bytes allocated when run out of memory.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="7061332d759d7e4d73c1b2e5cb0bf2bf"></a><!-- doxytag: member="slu_ddefs.h::fixupL" ref="7061332d759d7e4d73c1b2e5cb0bf2bf" args="(const int, const int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void fixupL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const &nbsp;</td>
          <td class="mdname" nowrap> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="4eb909967bdba5d1c9e1adcfcba55be1"></a><!-- doxytag: member="slu_ddefs.h::print_lu_col" ref="4eb909967bdba5d1c9e1adcfcba55be1" args="(char *, int, int, int *, GlobalLU_t *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void print_lu_col           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="04b5542748fcc2fee77b587e31bb0a02"></a><!-- doxytag: member="slu_ddefs.h::PrintPerf" ref="04b5542748fcc2fee77b587e31bb0a02" args="(SuperMatrix *, SuperMatrix *, mem_usage_t *, double, double, double *, double *, char *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void PrintPerf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b776edfed8eb517dc4d037e76ed2bb24"></a><!-- doxytag: member="slu_ddefs.h::sp_dgemm" ref="b776edfed8eb517dc4d037e76ed2bb24" args="(char *, char *, int, int, int, double, SuperMatrix *, double *, int, double, double *, int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int sp_dgemm           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>transa</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>transb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ldc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose   
   =======</pre><p>
<pre>   sp_d performs one of the matrix-matrix operations</pre><p>
<pre>      C := alpha*op( A )*op( B ) + beta*C,</pre><p>
<pre>   where  op( X ) is one of</pre><p>
<pre>      op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),</pre><p>
<pre>   alpha and beta are scalars, and A, B and C are matrices, with op( A ) 
   an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</pre><p>
<pre>   Parameters   
   ==========</pre><p>
<pre>   TRANSA - (input) char*
            On entry, TRANSA specifies the form of op( A ) to be used in 
            the matrix multiplication as follows:   
               TRANSA = 'N' or 'n',  op( A ) = A.   
               TRANSA = 'T' or 't',  op( A ) = A'.   
               TRANSA = 'C' or 'c',  op( A ) = conjg( A' ).   
            Unchanged on exit.</pre><p>
<pre>   TRANSB - (input) char*
            On entry, TRANSB specifies the form of op( B ) to be used in 
            the matrix multiplication as follows:   
               TRANSB = 'N' or 'n',  op( B ) = B.   
               TRANSB = 'T' or 't',  op( B ) = B'.   
               TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).   
            Unchanged on exit.</pre><p>
<pre>   M      - (input) int   
            On entry,  M  specifies  the number of rows of the matrix 
	     op( A ) and of the matrix C.  M must be at least zero. 
	     Unchanged on exit.</pre><p>
<pre>   N      - (input) int
            On entry,  N specifies the number of columns of the matrix 
	     op( B ) and the number of columns of the matrix C. N must be 
	     at least zero.
	     Unchanged on exit.</pre><p>
<pre>   K      - (input) int
            On entry, K specifies the number of columns of the matrix 
	     op( A ) and the number of rows of the matrix op( B ). K must 
	     be at least  zero.   
           Unchanged on exit.</pre><p>
<pre>   ALPHA  - (input) double
            On entry, ALPHA specifies the scalar alpha.</pre><p>
<pre>   A      - (input) SuperMatrix*
            Matrix A with a sparse format, of dimension (A-&gt;nrow, A-&gt;ncol).
            Currently, the type of A can be:
                Stype = NC or NCP; Dtype = SLU_D; Mtype = GE. 
            In the future, more general A can be handled.</pre><p>
<pre>   B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is 
            n when TRANSB = 'N' or 'n',  and is  k otherwise.   
            Before entry with  TRANSB = 'N' or 'n',  the leading k by n 
            part of the array B must contain the matrix B, otherwise 
            the leading n by k part of the array B must contain the 
            matrix B.   
            Unchanged on exit.</pre><p>
<pre>   LDB    - (input) int
            On entry, LDB specifies the first dimension of B as declared 
            in the calling (sub) program. LDB must be at least <a class="el" href="slamch_8c.html#ffe776513b24d84b39af8ab0930fef7f">max( 1, n )</a>.  
            Unchanged on exit.</pre><p>
<pre>   BETA   - (input) double
            On entry, BETA specifies the scalar beta. When BETA is   
            supplied as zero then C need not be set on input.</pre><p>
<pre>   C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).   
            Before entry, the leading m by n part of the array C must 
            contain the matrix C,  except when beta is zero, in which 
            case C need not be set on entry.   
            On exit, the array C is overwritten by the m by n matrix 
	     ( alpha*op( A )*B + beta*C ).</pre><p>
<pre>   LDC    - (input) int
            On entry, LDC specifies the first dimension of C as declared 
            in the calling (sub)program. LDC must be at least <a class="el" href="slamch_8c.html#ffe776513b24d84b39af8ab0930fef7f">max(1,m)</a>.   
            Unchanged on exit.</pre><p>
<pre>   ==== Sparse Level 3 Blas routine.   
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="505f6c005fe6a0cdcbf00512a1e4823a"></a><!-- doxytag: member="slu_ddefs.h::sp_dgemv" ref="505f6c005fe6a0cdcbf00512a1e4823a" args="(char *, double, SuperMatrix *, double *, int, double, double *, int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int sp_dgemv           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>incx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>incy</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
   Purpose   
   =======</pre><p>
<pre>   <a class="el" href="dsp__blas2_8c.html#221dfb4c5cbc550095a989c61fec4993">sp_dgemv()</a>  performs one of the matrix-vector operations   
      y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   
   where alpha and beta are scalars, x and y are vectors and A is a
   sparse A-&gt;nrow by A-&gt;ncol matrix.</pre><p>
<pre>   Parameters   
   ==========</pre><p>
<pre>   TRANS  - (input) char*
            On entry, TRANS specifies the operation to be performed as   
            follows:   
               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.   
               TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.   
               TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.</pre><p>
<pre>   ALPHA  - (input) double
            On entry, ALPHA specifies the scalar alpha.</pre><p>
<pre>   A      - (input) SuperMatrix*
            Matrix A with a sparse format, of dimension (A-&gt;nrow, A-&gt;ncol).
            Currently, the type of A can be:
                Stype = NC or NCP; Dtype = SLU_D; Mtype = GE. 
            In the future, more general A can be handled.</pre><p>
<pre>   X      - (input) double*, array of DIMENSION at least   
            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'   
            and at least   
            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.   
            Before entry, the incremented array X must contain the   
            vector x.</pre><p>
<pre>   INCX   - (input) int
            On entry, INCX specifies the increment for the elements of   
            X. INCX must not be zero.</pre><p>
<pre>   BETA   - (input) double
            On entry, BETA specifies the scalar beta. When BETA is   
            supplied as zero then Y need not be set on input.</pre><p>
<pre>   Y      - (output) double*,  array of DIMENSION at least   
            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'   
            and at least   
            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.   
            Before entry with BETA non-zero, the incremented array Y   
            must contain the vector y. On exit, Y is overwritten by the 
            updated vector y.</pre><p>
<pre>   INCY   - (input) int
            On entry, INCY specifies the increment for the elements of   
            Y. INCY must not be zero.</pre><p>
<pre>   ==== Sparse Level 2 Blas routine.   
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="f7ab3b2b81d10a67b258956bfc468740"></a><!-- doxytag: member="slu_ddefs.h::sp_dtrsv" ref="f7ab3b2b81d10a67b258956bfc468740" args="(char *, char *, char *, SuperMatrix *, SuperMatrix *, double *, SuperLUStat_t *, int *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int sp_dtrsv           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>diag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
   Purpose
   =======</pre><p>
<pre>   <a class="el" href="dsp__blas2_8c.html#aa92ff654356fe62f70ebef5815627e4">sp_dtrsv()</a> solves one of the systems of equations   
       A*x = b,   or   A'*x = b,
   where b and x are n element vectors and A is a sparse unit , or   
   non-unit, upper or lower triangular matrix.   
   No test for singularity or near-singularity is included in this   
   routine. Such tests must be performed before calling this routine.</pre><p>
<pre>   Parameters   
   ==========</pre><p>
<pre>   uplo   - (input) char*
            On entry, uplo specifies whether the matrix is an upper or   
             lower triangular matrix as follows:   
                uplo = 'U' or 'u'   A is an upper triangular matrix.   
                uplo = 'L' or 'l'   A is a lower triangular matrix.</pre><p>
<pre>   trans  - (input) char*
             On entry, trans specifies the equations to be solved as   
             follows:   
                trans = 'N' or 'n'   A*x = b.   
                trans = 'T' or 't'   A'*x = b.
                trans = 'C' or 'c'   A'*x = b.</pre><p>
<pre>   diag   - (input) char*
             On entry, diag specifies whether or not A is unit   
             triangular as follows:   
                diag = 'U' or 'u'   A is assumed to be unit triangular.   
                diag = 'N' or 'n'   A is not assumed to be unit   
                                    triangular.</pre><p>
<pre>   L       - (input) SuperMatrix*
	       The factor L from the factorization Pr*A*Pc=L*U. Use
             compressed row subscripts storage for supernodes,
             i.e., L has types: Stype = SC, Dtype = SLU_D, Mtype = TRLU.</pre><p>
<pre>   U       - (input) SuperMatrix*
	        The factor U from the factorization Pr*A*Pc=L*U.
	        U has types: Stype = NC, Dtype = SLU_D, Mtype = TRU.</pre><p>
<pre>   x       - (input/output) double*
             Before entry, the incremented array X must contain the n   
             element right-hand side vector b. On exit, X is overwritten 
             with the solution vector x.</pre><p>
<pre>   info    - (output) int*
             If *info = -i, the i-th argument had an illegal value.
 </pre>     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Aug 1 22:40:40 2008 for SuperLU by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
